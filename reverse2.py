# SA - Given p,q and e.. recover and use private key w/ Extended Euclidean Algorithm - crypto150-what_is_this_encrypti$
# @author intrd - http://dann.com.br/ (original script here: http://crypto.stackexchange.com/questions/19444/rsa-given$
# @license Creative Commons Attribution-ShareAlike 4.0 International License - http://creativecommons.org/licenses/by-$

import binascii, base64

p = 749302577646506281962992147553524167446082679278552088138715834326527417000928250488494103985293310916319365183030$
q = 702085452778756673545885838155545264832284500826661290684484793707033348037396328414664907425227875369689724589843$
e = 308020079179525084227928690216891939274850163327136225270252191051542544723446272849477797262809954319474542927824$
ct = 44641914821074071930297814589851746700593470770417111804648920018396305246956127337150936081144106405284134845851$

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
        gcd = b
    return gcd, x, y

n = p*q #product of primes
phi = (p-1)*(q-1) #modular multiplicative inverse
gcd, a, b = egcd(e, phi) #calling extended euclidean algorithm
d = a #a is decryption key

out = hex(d)
print("d_hex: " + str(out));
print("n_dec: " + str(d));

pt = pow(ct, d, n)
print("pt_dec: " + str(pt))

out = hex(pt)
out = str(out[2:-1])
print "flag"
print out.decode("hex")

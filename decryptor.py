import string

def decrypt(key, msg):
  lkey = list(key)
  lmsg = list(msg)
  for char_key in reversed(lkey):
      for i in reversed(range(len(lmsg))):
          if i == 0:
              tmp = ord(lmsg[i]) - (ord(char_key) + ord(lmsg[-1]))
          else:
              tmp = ord(lmsg[i]) - (ord(char_key) + ord(lmsg[i-1]))
          while tmp < 0:
              tmp += 256
          if tmp > 256:
            tmp = 105 #randomly picked to fix out-of-range chars
          elif tmp == 0:
            tmp = 90 #randomly picked to fix out-of-range chars
          lmsg[i] = chr(tmp)
  return ''.join(lmsg)

#checks the output from crypto and sees if at least 60% is ascii letters and returns true for possible plaintext
def is_plaintext(ptext):
    num_letters = sum(map(lambda x : 1 if x in string.ascii_letters else 0, ptext))
    if num_letters / len(ptext) >= .6:
      return True

def main():
  with open('ciphertext', 'r', encoding='latin1') as ctext, open('key', 'r', encoding='latin1') as rock:
      cipher = ctext.read()
      #print(cipher + ': ' + str(len(cipher))) #for testing that the cypher is being read properly.  Needed latin encoding, as UTF-8 invalid

      for line in rock:
        line = line.strip() #remove any spaces or newlines
        #print('trying: ' + line) #testing file read purposes...too many lines of output to keep

        ptext = decrypt(line, cipher)
        
        #only print the result if it contains > 60% letters, can be tweaked.
        if is_plaintext(ptext): 
          print('plaintext found: ' + ptext)
          print('The key was: ' + line)
          exit() #exit on positive result. Remove if false positives.
        
if (__name__ == '__main__'): 
  try: 
      main() 
  except KeyboardInterrupt: 
      exit()
